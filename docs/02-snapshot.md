# PostgreSQL Snapshot 이해하기

## Snapshot이란?

**Snapshot(스냅샷)**은 특정 시점의 데이터베이스 "상태"를 나타내는 정보입니다.
PostgreSQL은 스냅샷을 사용해 "어떤 트랜잭션의 변경이 보이고, 어떤 것이 보이지 않는지"를 결정합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                        Snapshot                              │
│                                                              │
│  "이 시점에서 커밋된 트랜잭션의 변경만 볼 수 있다"              │
│                                                              │
│  구성 요소:                                                   │
│  • xmin: 아직 진행 중인 가장 오래된 트랜잭션 ID               │
│  • xmax: 다음에 할당될 트랜잭션 ID                           │
│  • xip[]: 스냅샷 생성 시점에 진행 중이던 트랜잭션 목록         │
└─────────────────────────────────────────────────────────────┘
```

---

## Snapshot의 세 가지 구성 요소

### 1. xmin (가장 오래된 활성 트랜잭션)
- 스냅샷 생성 시점에 **아직 진행 중인 가장 오래된 트랜잭션 ID**
- 이 값보다 작은 트랜잭션 ID의 변경은 모두 커밋되었거나 abort됨
- xmin보다 작은 xid를 가진 튜플은 "확실히 visible하거나 invisible"

### 2. xmax (다음 트랜잭션 ID)
- 스냅샷 생성 시점에 **아직 할당되지 않은 가장 작은 트랜잭션 ID**
- 이 값 이상의 트랜잭션은 스냅샷 "이후"에 시작된 것
- xmax 이상의 xid를 가진 튜플은 "절대 보이지 않음"

### 3. xip[] (진행 중인 트랜잭션 목록)
- xmin과 xmax 사이에서 **아직 커밋되지 않은 트랜잭션들의 목록**
- 이 목록에 있는 트랜잭션의 변경은 "보이지 않음"

```
시간축 →

 xmin           xip[]에 있는 것들          xmax
  ↓             ↓   ↓   ↓                  ↓
──┬─────────────┬───┬───┬──────────────────┬────────
  │             │   │   │                  │
  │ 확실히      │ 개별 체크 필요           │ 절대
  │ 판단 가능   │ (커밋 여부 확인)         │ 안 보임
  │             │   │   │                  │
```

---

## 튜플 가시성 판단 규칙

스냅샷을 사용해 튜플이 보이는지 판단하는 규칙:

```sql
-- 튜플의 xmin(생성 트랜잭션)이 스냅샷에서 "커밋됨"으로 보이고
-- 튜플의 xmax(삭제 트랜잭션)가 없거나 "커밋 안됨"으로 보이면
-- → 이 튜플은 VISIBLE!
```

### 상세 규칙

```
튜플의 xmin이 "커밋됨"인가?
├─ xmin < snapshot.xmin → 예 (오래된 트랜잭션, 이미 완료)
├─ xmin >= snapshot.xmax → 아니오 (미래 트랜잭션)
├─ xmin IN snapshot.xip[] → 아니오 (당시 진행 중이었음)
└─ 그 외 → 예 (커밋됨)

튜플의 xmax가 "커밋됨"인가? (삭제/수정됨?)
├─ xmax = 0 → 아니오 (삭제 안됨)
├─ xmax < snapshot.xmin → 예 (이미 삭제됨)
├─ xmax >= snapshot.xmax → 아니오 (미래에 삭제 예정?)
├─ xmax IN snapshot.xip[] → 아니오 (당시 삭제 진행 중)
└─ 그 외 → 예 (삭제됨)
```

---

## 격리 수준별 Snapshot 생성 시점

**이것이 격리 수준의 핵심 차이입니다!**

### READ COMMITTED
```
┌─────────────────────────────────────────────────────────────┐
│  각 쿼리(Statement)마다 새로운 스냅샷 생성                    │
│                                                              │
│  BEGIN;                                                      │
│  SELECT * FROM t; ←── 스냅샷 #1 생성                         │
│  -- 다른 트랜잭션이 커밋 --                                   │
│  SELECT * FROM t; ←── 스냅샷 #2 생성 (다른 결과 가능!)        │
│  COMMIT;                                                     │
└─────────────────────────────────────────────────────────────┘
```

### REPEATABLE READ
```
┌─────────────────────────────────────────────────────────────┐
│  트랜잭션의 첫 번째 쿼리에서 스냅샷 생성, 이후 재사용          │
│                                                              │
│  BEGIN ISOLATION LEVEL REPEATABLE READ;                      │
│  SELECT * FROM t; ←── 스냅샷 #1 생성                         │
│  -- 다른 트랜잭션이 커밋 --                                   │
│  SELECT * FROM t; ←── 스냅샷 #1 재사용 (같은 결과!)           │
│  COMMIT;                                                     │
└─────────────────────────────────────────────────────────────┘
```

### SERIALIZABLE
```
┌─────────────────────────────────────────────────────────────┐
│  REPEATABLE READ와 동일하게 스냅샷 고정                       │
│  + 직렬화 충돌 감지 (SSI: Serializable Snapshot Isolation)   │
│                                                              │
│  다른 트랜잭션과의 의존성을 추적하여                          │
│  직렬화 불가능한 경우 abort                                   │
└─────────────────────────────────────────────────────────────┘
```

---

## Snapshot 직접 확인하기

PostgreSQL 13+에서는 스냅샷을 직접 조회할 수 있습니다:

```sql
-- 현재 스냅샷 확인
SELECT pg_current_snapshot();
-- 결과 예: 100:105:100,102,104

-- 해석: xmin:xmax:xip_list
-- xmin = 100: 가장 오래된 활성 트랜잭션
-- xmax = 105: 다음 할당될 트랜잭션 ID
-- xip = 100,102,104: 진행 중인 트랜잭션들

-- 스냅샷 구성 요소 개별 조회
SELECT pg_snapshot_xmin(pg_current_snapshot()) as xmin;
SELECT pg_snapshot_xmax(pg_current_snapshot()) as xmax;
SELECT pg_snapshot_xip(pg_current_snapshot()) as xip_list;
```

---

## 예제: 스냅샷으로 가시성 판단

```
상황:
- 스냅샷: 100:105:102,103
  (xmin=100, xmax=105, 진행 중=102,103)

튜플 A: xmin=98, xmax=0
- xmin(98) < snapshot.xmin(100) → 커밋됨
- xmax = 0 → 삭제 안됨
- 결론: VISIBLE ✓

튜플 B: xmin=102, xmax=0
- xmin(102) IN xip[102,103] → 아직 커밋 안됨
- 결론: INVISIBLE ✗

튜플 C: xmin=101, xmax=0
- xmin(101) >= xmin(100) AND < xmax(105)
- xmin(101) NOT IN xip[102,103]
- 결론: VISIBLE ✓ (101번 트랜잭션은 커밋됨)

튜플 D: xmin=95, xmax=104
- xmin(95) < snapshot.xmin(100) → 생성은 커밋됨
- xmax(104) IN xip[102,103,104] → 삭제는 아직 커밋 안됨
- 결론: VISIBLE ✓ (삭제가 보이지 않으므로)
```

---

## 왜 Snapshot이 중요한가?

1. **MVCC의 핵심 메커니즘**
   - 락 없이 읽기/쓰기 동시 진행 가능
   - 각 트랜잭션이 "자신만의 버전"을 봄

2. **격리 수준 구현**
   - 스냅샷 생성 시점만 다르게 하여 격리 수준 구현
   - 복잡한 락 관리 없이 일관성 보장

3. **Long-running Query 보호**
   - 쿼리 시작 시점의 스냅샷 유지
   - 쿼리 실행 중 데이터 변경에 영향받지 않음

---

## 다음 단계

스냅샷 개념을 이해했다면, 다음 실습으로 직접 확인해보세요:

1. `lab02b_snapshot.py` - 스냅샷 직접 확인 실습
2. `lab03_isolation.py` - 격리 수준별 스냅샷 동작 비교
